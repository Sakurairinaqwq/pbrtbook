\section{习题}\label{sec:习题04}

\begin{enumerate}
    \item \circletwo pbrt中两种加速结构最坏情形下的场景是什么样的？
          （考虑方法无法分别处理好的特殊几何构造。）
          构建具有这些特点的场景，度量pbrt随着你增加更多图元后的性能。
          其中一者的最坏情况用另一个渲染的表现如何？
    \item \circletwo 实现层次化网格加速器，改进与大量图元重合的格子
          而不是用更细的子网格存储其几何体。
          （例如见\citet{Jevans1989:23}解决
          该问题的一种方法以及\citet{4342587}决定何时值得细化的高效方法。）
          比较两个加速器与本章加速器针对非层次化网格的构建性能和渲染性能。
    \item \circletwo 为构建加速器实现更智能的重合测试。
          用物体的边界框确定它们重合于kd树划分的哪一侧可能因为造成不必要的相交测试而有损性能。
          因此向形状接口添加方法{\ttfamily bool \refvar{Shape}{}::Overlaps(const \refvar{Bounds3f}{} \&) const}，
          它接收世界空间边界框并确定形状是否真的和给定框重合。
          默认实现可以从形状获取世界边界并用它测试，可以为频繁使用的形状编写专门化版本。
          为\refvar{Spheres}{}和\refvar{Triangles}{}实现该方法，
          并修改\refvar{KdTreeAccel}{}来调用它。
          你可能发现阅读\citet{doi:10.1080/10867651.2001.10487535}关于快速
          三角形-框重合测试的论文会有帮助。度量该修改带来的pbrt整体性能的变化，
          分别说明构建加速结构多花的时间和因为更少的相交而少花的光线-物体相交时间。
          对于大量场景，确定因为该修改少执行了多少次相交测试。
    \item \circletwo 在pbrt的BVH实现中实现“分割剪裁”\sidenote{译者注：原文split clipping。}。
          阅读\citet{4342593}、\citet{4634636}、
          \citet{10.1145/1572769.1572771}以及
          \citet{10.1145/2492045.2492055}的论文，
          并实现他们之一的方法来把相对于其表面积具有巨大边界框的图元细分为多个子图元以构建树。
          （这样做可能要求修改\refvar{Shape}{}接口；例如你可能会想设计
          允许一些形状表示自己无法细分自己的新接口，这样你只需要为三角形实现该方法。）
          为渲染实际场景度量提升情况；收集该数据的优异方法是做Dammertz和Keller做的实验，
          其中场景在一个动画的渐进帧中绕轴旋转。
          一般许多原本是轴对齐的三角形旋转得多了就会有非常宽松的边界框，
          如果不用分割剪裁就会导致巨大的性能减退。
    \item \circletwo \refvar{BVHAccel}{}中HLBVH构建算法所用的30位莫顿码
          对于大型场景可能不够（注意到它们每个维度只可表示$2^{10}=1024$步）。
          把\refvar{BVHAccel}{}改成用64位整数，其中63位莫顿码给HLBVH。
          用各种场景比较你的方法与原始方法的性能。
          有性能极大提升的场景吗？有性能下降的场景吗？
    \item \circletwo 为构建BVH或kd树研究替代的SAH开销函数。
          差的开销函数会多大损害其性能？比起当前的有多大提升？
          （见“扩展阅读”一节关于可以怎样改进SAH的讨论。）
    \item \circlethree \refvar{BVHAccel}{}尤其是\refvar{KdTreeAccel}{}的构建时间
          会在整个渲染时间中占有重要比重，除了HLBVH外，本章的实现不会并行化构建加速结构。
          研究例如\citet{4342588}和\citet{10.1111/j.1467-8659.2007.01062.x}
          描述的加速器并行化构建技术，并在pbrt中实现其中一个。
          在加速器构建中你取得了多少加速？用额外的处理器加速了多少？
          对于整个渲染而言度量你的改动转化为加速了多少。
          你的实现对哪种场景具有最好的作用？
    \item \circlethree 为光线相交加速使用空间数据结构的思想可以推广到
          包含空间数据结构，它自身又持有其他空间数据结构而不是图元。
          我们不仅可以有网格且里面还有包含许多图元的子网格，
          还可以让场景组织为层次包围盒，其中叶子节点是持有空间上相邻图元小集合的网格。
          这样的混合技术可以带来各种基于空间数据结构的光线相交加速方法的最好效果。
          在pbrt中，因为几何图元和相交加速器都继承自基类\refvar{Primitive}{}且
          因此提供相同接口，所以很容易按该方式混合和匹配。
          修改pbrt以构建混合加速结构——例如，用BVH粗略排序场景几何体然后
          在树的叶子处用均匀网格管理局部空间密集的几何体集。
          比起当前的加速器度量使用该方法的渲染方案所用的运行时间和内存。
    \item \circletwo \citet{10.1080/2151237X.2007.10129248}描述了
          甚至比\refvar{BVHAccel}{}用的还高效的光线-框相交测试。
          开始时它为每条光线做更多计算但用更少计算来对单个边界框做测试以补偿之。
          在pbrt中实现他们的方法，并为各种场景度量渲染时间的变化。
          有使前面额外的工作不划算的简单场景吗？
          比起简单场景的提升，高度复杂场景的提升如何？
    \item \circletwo 阅读\citet{10.5555/1839214.1839242}关于内存高效化BVH的论文，
          并在pbrt中实现他们的方法。比起\refvar{BVHAccel}{}他们方法的内存使用如何？
          比较你方法的渲染性能和pbrt当前的性能。比较讨论你的和他们文中报告的结果。
    \item \circletwo 修改pbrt以在\refvar{KdTreeAccel}{}中使用“邮箱”优化
          来避免和重合于多个kd树节点的图元反复相交。
          如果pbrt是多线程的，你可能最好考虑\citet{Benthin_2006}建议的哈希邮箱
          \sidenote{译者注：原文hashed mailboxing。}法或\citet{shevtsov2007ray}
          的逆邮箱\sidenote{译者注：原文inverse mailboxing。}算法。
          用各种场景度量和当前实现相比的性能变化。
          运行时间的变化与统计报告中光线-图元相交测试次数变化的关联如何？
    \item \circlethree 通常可以把一些近似引入到极复杂几何体
          的阴影计算中（例如考虑一棵树的枝叶阴影）。
          \citet{4634616}建议为空间区域用预先筛选的方向多变的遮挡表示
          来增广加速结构。当阴影射线穿过这些区域时，会返回近似的可见性概率
          而不是二元结果，减少树的遍历以及物体相交测试的开销。
          在pbrt中实现该方法，比较其和当前实现的性能。在渲染的图像中你看到了什么变化吗？
\end{enumerate}